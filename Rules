#!/usr/bin/env ruby

require 'date'
require 'nenv'

preprocess do
  @config[:google_api_key] = Nenv.lifepreserver_api_key

  @config[:production] = Nenv.nanoc_env? && Nenv.nanoc_env == 'production' # See https://github.com/nanoc/nanoc/issues/487

  populate_version_history

  def assign_date_to_all_items
    @items.each do |item|
      item[:created_at] = item.key?(:created_at) ? attribute_to_time(item[:created_at]) : Time.now
      item[:updated_at] = attribute_to_time(item[:updated_at]) if item.key?(:updated_at)
    end
  end

  def mark_items_as_hidden_that_should_be_hidden

    hidden_predicates = [
      ->(item) { @config[:production] ? (item.key?(:published) && !item[:published]) : false },
      ->(item) { item.identifier.exts.include?('js') },
      ->(item) { item.identifier.ext =~ /css/ },
      ->(item) { item.identifier =~ /^\/assets\/components/ }
    ]

    should_be_hidden = disjoin(*hidden_predicates)

    @items.each { |item| item[:is_hidden] = true if should_be_hidden.call(item) }

  end

  def include_analytics
    @items.each { |item| item[:endbody] = Array(item[:endbody]) << 'analytics' }
  end

  def include_video_partials_when_has_media
    @items.select { |item| item.key?(:has_media) }.each do |item|
      item[:head] = Array(item[:head]) << 'video-styles'
      item[:endbody] = Array(item[:endbody]) << 'video-scripts'
    end
  end

  def include_hypothesis
    @items.each { |item| item[:endbody] = Array(item[:endbody]) << 'hypothesis' }
  end

  # We don't want anything nanoc specific in the spec folder, so have to use
  # some trickery to get the information we need for searches.
  def extract_metadata_from_specification_documents
    require 'nokogiri'

    @items.select { |item| item.identifier =~ /^\/spec/ }.each do |item|
      case item.identifier.ext
      when 'html'
        doc = Nokogiri::HTML(File.open(item[:filename]))
        item[:title] = doc.title
        item[:description] = doc.xpath('//meta[@name="description"]/@content').map(&:value).first
      else
        item[:is_hidden_from_human_search] = true
      end
    end
  end

  generate_author_uris(published_blog_posts)
  generate_tag_pages(published_blog_posts)
  generate_author_pages(published_blog_posts)
  generate_blog_archives(published_blog_posts)

  assign_date_to_all_items

  mark_items_as_hidden_that_should_be_hidden

  include_analytics if @config[:production]
  include_hypothesis if @config[:production]
  include_video_partials_when_has_media

  extract_metadata_from_specification_documents

end

ignore '/**/_*'
ignore '/project/**/*'

# Aggregated JavaScript scripts
 
compile '/assets/scripts/*.js.erb' do
  filter :erb, trim_mode: '>'
  filter :uglify_js if @config[:production]
  write '/js/' + File.basename("#{@item.identifier.without_exts}#{fingerprint(@item[:filename]) if @config[:production]}.js")
end

# Other JavaScript scripts
 
compile '/assets/scripts/*.js' do
  filter :uglify_js if @config[:production]
  write '/js/' + File.basename(@item.identifier.to_s)
end

# Stylesheets

compile '/assets/stylesheets/**/*.htc' do
  write '/css/' + File.basename(@item.identifier.to_s)
end

compile '/assets/stylesheets/**/*' do
  filter :sass, Compass.sass_engine_options
  write '/css/' + File.basename("#{@item.identifier.without_ext}#{fingerprint(@item[:filename]) if @config[:production]}.css")
end

route '/assets/components/pygments/css/*' do
  '/css/pygments/' + File.basename(@item.identifier.to_s)
end

# Favicon and images

route '/assets/images/*' do
  '/images/' + File.basename(@item.identifier.to_s)
end

# Fonts and other files

route '/assets/fonts/**/*' do
  '/fonts/' + File.basename(@item.identifier.to_s)
end

ignore '/assets/components/mediaelement/build/DO NOT CHANGE THESE FILES. USE -src- FOLDER.txt'
route '/assets/components/mediaelement/build/*' do
  '/js/mediaelement/' + File.basename(@item.identifier.to_s)
end

ignore '/assets/components/**/*'

# Sitemap

compile '/sitemap.erb' do
  filter :erb
  write '/sitemap.xml'
end

# Specification documents (N3)

compile '/specifications/**/*.ttl' do
  filter :rdf_distiller, format: :turtle
end

compile '/specifications/**/*.ttl', rep: :jsonld do
  filter :rdf_distiller, format: :jsonld
  write item.identifier.without_ext + '.jsonld'
end

compile '/specifications/**/*.ttl', rep: :rdfxml do
  filter :rdf_distiller, format: :rdfxml
  write item.identifier.without_ext + '.rdf'
end

compile '/specifications/**/*.ttl', rep: :html do
  layout '/specifications/vocabulary.*'
  filter :cache_buster if @config[:production]
  filter :html5small if @config[:production]
  write item.identifier.without_ext + '.html'
end

layout '/specifications/vocabulary.*', :rdf_distiller, format: :html

compile '/specifications/**/*.md' do
  filter :kramdown, @config[:kramdown]
  filter :colorize_syntax, default_colorizer: :pygmentize, pygmentize: { nowrap: 'True' }
  filter :spellchecker unless @config[:production]
  layout '/specifications/default.*'
  filter :rubypantsunicode
  filter :cache_buster if @config[:production]
  filter :html5small if @config[:production]
end

passthrough '/specifications/**/*.html'


# vcard and QR code

compile '/company/_', rep: :vcard do
  filter :vcard, @config[:company].merge(kind: 'org')
  write "/company/pentandra#{fingerprint(@item[:filename]) if @config[:production]}.vcf"
end

compile '/company/_', rep: :qrcode do
  filter :vcard, @config[:company].merge(kind: 'org')
  filter :qrcode, @config[:qrcode]
  write "/images/pentandra-qrcode#{fingerprint(@item[:filename]) if @config[:production]}.png"
end

# Blog index

compile '/blog/{index,recent}.erb' do
  filter :erb, trim_mode: '>'
  layout '/blog/default.*'
  filter :rubypantsunicode
  filter :cache_buster if @config[:production]
  filter :html5small if @config[:production]
end

# Blog feeds

compile '/**/feed.erb' do
  filter :erb
  write item.identifier.without_ext + '.atom'
end

# Blog tags, authors, and archives

compile '/{tags,authors,archives}/**/*' do
  filter :erb, trim_mode: '>'
  filter :rubypantsunicode
  filter :cache_buster if @config[:production]
  filter :html5small if @config[:production]
end

# Blog posts

compile '/blog/**/*.md' do
  filter :erb, trim_mode: '>'
  filter :kramdown, @config[:kramdown]
  filter :colorize_syntax, default_colorizer: :pygmentize, pygmentize: { nowrap: 'True' }
  filter :absolutify_local_paths
  filter :spellchecker unless @config[:production]
  layout '/blog/article.*'
  filter :rubypantsunicode
  filter :cache_buster if @config[:production]
  filter :html5small if @config[:production]
end

# Passthrough

passthrough '/humans.txt'
passthrough '/robots.txt'

# HTML, ERB, and Markdown files

compile '/**/*.erb' do
  filter :erb, trim_mode: '>'
  filter :spellchecker unless @config[:production]
  layout '/default.*'
  filter :rubypantsunicode
  filter :cache_buster if @config[:production]
  filter :html5small if @config[:production]
end

compile '/**/*.html' do
  filter :spellchecker unless @config[:production]
  layout '/default.*'
  filter :rubypantsunicode
  filter :cache_buster if @config[:production]
  filter :html5small if @config[:production]
end

compile '/**/*' do
end

route '/404.erb' do
  item.identifier.without_ext + '.html'
end

route '/**/index.{erb,html,md}' do
  item.identifier.without_ext + '.html'
end

route '/**/*.{erb,html,md}' do
  item.identifier.without_ext + '/index.html'
end

route '/**/*' do
  item.identifier.to_s
end

layout '/**/*', :erb, trim_mode: '>'
