#!/usr/bin/env ruby

require 'date'

preprocess do
  @config[:google_api_key] = ENV['LIFEPRESERVER_API_KEY']

  @config[:production] = !ENV['NANOC_ENV'].nil? && ENV['NANOC_ENV'] == 'production' # See https://github.com/nanoc/nanoc/issues/487

  def mark_items_as_hidden_that_should_be_hidden

    hidden_predicates = [
      lambda { |item| @config[:production] ? (item.key?(:published) and not item[:published]) : false },
      lambda { |item| item.identifier.exts.include?('js') },
      lambda { |item| item.identifier.ext =~ /css/ },
      lambda { |item| item.identifier =~ /^\/assets\/components/ }
    ]

    should_be_hidden = disjoin(*hidden_predicates)

    @items.each { |item| item[:is_hidden] = true if should_be_hidden.call(item) }

  end

  def include_video_partials_when_has_media
    @items.select { |item| item.key?(:has_media) }.each do |item|
      item[:head] ||= []
      item[:endbody] ||= []

      item[:head] << 'video-styles'
      item[:endbody] << 'video-scripts'
    end
  end

  # Includes any custom json-ld contexts for RDF turtle data.
  #
  # Looks for a file called `context.json` in the same directory as the turtle
  # source file, and adds it to the item's metadata under the key `context`.
  def add_custom_jsonld_contexts
    @items.each do |item|
      if item.identifier.ext == 'ttl' then
        context_path = item[:filename].rpartition("/")[0] + "/context.json"
        context_doc = JSON.parse(File.read context_path) if File.exists? context_path
        unless context_doc.nil? then
          item[:context] = context_doc["@context"] unless context_doc["@context"].nil?
          unless item[:context].nil? then
            base_context = [item[:context]].find { |k,v| k.include?("@base") }
            item[:base_uri] = base_context["@base"] unless base_context.nil?
          end
        end
      end
    end
  end

  # We don't want anything nanoc specific in the spec folder, so have to use
  # some trickery to get the information we need for searches.
  def extract_metadata_from_specification_documents
    require 'nokogiri'

    @items.select { |item| item.identifier =~ /^\/spec/ }.each do |item|
      case item.identifier.ext
      when 'html'
        doc = Nokogiri::HTML(File.open(item[:filename]))
        item[:title] = doc.at_css("title").inner_text
      else
        item[:is_hidden_from_human_search] = true
      end
    end
  end

  mark_items_as_hidden_that_should_be_hidden

  generate_author_uris(publishing_articles())
  generate_tag_pages(publishing_articles())
  generate_author_pages(publishing_articles())
  generate_blog_archives(publishing_articles())

  include_video_partials_when_has_media

  add_custom_jsonld_contexts
  extract_metadata_from_specification_documents

end

# Aggregated JavaScript scripts
 
compile '/assets/scripts/*.js.erb' do
  filter :erb
  filter :uglify_js if @config[:production]
  write '/js/' + File.basename(@item.identifier.without_exts + fingerprint(@item[:filename]) + '.js')
end

# Other JavaScript scripts
 
compile '/assets/scripts/*.js' do
  filter :uglify_js if @config[:production]
  write '/js/' + File.basename(@item.identifier.to_s)
end

# Stylesheets

ignore '/assets/stylesheets/**/_*'

compile '/assets/stylesheets/**/*.htc' do
  write '/css/' + File.basename(@item.identifier.to_s)
end

compile '/assets/stylesheets/**/*' do
  filter :sass, Compass.sass_engine_options
  write '/css/' + File.basename(@item.identifier.without_ext + fingerprint(@item[:filename]) + '.css')
end

route '/assets/components/pygments/css/*' do
  '/css/pygments/' + File.basename(@item.identifier.to_s)
end

# Favicon and images

route '/assets/images/*' do
  '/images/' + File.basename(@item.identifier.to_s)
end

# Fonts and other files

route '/assets/fonts/**/*' do
  '/fonts/' + File.basename(@item.identifier.to_s)
end

route '/assets/files/**/*' do
  '/downloads/' + File.basename(@item.identifier.to_s)
end

ignore '/assets/components/mediaelement/build/DO NOT CHANGE THESE FILES. USE -src- FOLDER.txt'
route '/assets/components/mediaelement/build/*' do
  '/js/mediaelement/' + File.basename(@item.identifier.to_s)
end

ignore '/assets/components/**/*'

# Sitemap

compile '/sitemap.erb' do
  filter :erb
  write '/sitemap.xml'
end

# Specification documents (N3)

compile '/spec/**/*.ttl', rep: :jsonld do
  filter :rdf_distiller, in: :ttl, out: :jsonld
  write item.identifier.without_ext + '.jsonld'
end

compile '/spec/**/*.ttl', rep: :rdfxml do
  filter :rdf_distiller, in: :ttl, out: :rdfxml
  write item.identifier.without_ext + '.rdf'
end

passthrough '/spec/**/*'

# vcard and QR code

compile '/company/index.*', rep: :vcard do
  filter :vcard, @config[:vcard]
  write '/company/pentandra' + fingerprint(@item[:filename]) + '.vcf'
end

compile '/company/index.*', rep: :qrcode do
  filter :vcard, @config[:vcard]
  filter :qrcode, @config[:qrcode]
  write '/images/pentandra-qrcode' + fingerprint(@item[:filename]) + '.png'
end

# Blog index

compile '/blog/index.erb' do
  filter :erb
  layout '/blog/default.*'
  filter :cache_buster
  filter :rubypantsunicode
  filter :html5small if @config[:production]
  write item.identifier.without_ext + '.html'
end

# Blog feed

compile '/blog/feed_private.erb' do
  filter :erb
  write item.identifier.without_ext + '/index.atom'
end

# Blog tags, authors, and archives

compile '/{tags,authors,archives}/**/*' do
  filter :erb
  filter :cache_buster
  filter :rubypantsunicode
  filter :html5small if @config[:production]
  write item.identifier.without_ext + '.html'
end

# Blog posts

compile '/blog/**/*.{md,mmd}' do
  filter :erb
  if 'mmd' == @item[:extension]
  else # assume Markdown
    filter :kramdown, @config[:kramdown]
  end
  filter :colorize_syntax, default_colorizer: :pygmentize, pygmentize: { nowrap: 'True' }
  filter :absolutify_local_paths
  filter :spellchecker unless @config[:production]
  layout '/blog/article.*'
  filter :cache_buster
  filter :rubypantsunicode
  filter :html5small if @config[:production]
  write item.identifier.without_ext + '.html'
end

# Passthrough

passthrough '/humans.txt'
passthrough '/robots.txt'

# HTML, ERB, and Markdown files

compile '/**/*.erb' do
  filter :erb
  filter :spellchecker unless @config[:production]
  layout '/default.*'
  filter :cache_buster
  filter :rubypantsunicode
  filter :html5small if @config[:production]
end

compile '/**/*.html' do
  filter :spellchecker unless @config[:production]
  layout '/default.*'
  filter :cache_buster
  filter :rubypantsunicode
  filter :html5small if @config[:production]
end

compile '/**/*' do
end

route '/404.erb' do
  item.identifier.without_ext + '.html'
end

route '/**/index.{erb,html,md,mmd}' do
  item.identifier.without_ext + '.html'
end

route '/**/*.{erb,html,md,mmd}' do
  item.identifier.without_ext + '/index.html'
end

route '/**/*' do
  item.identifier.to_s
end

layout '/**/*', :erb
